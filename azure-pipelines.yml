trigger:
  branches:
    include:
      - master
      - dev

variables:
  - group: azure-credentials

stages:
- stage: Build
  displayName: Build and analyze
  jobs:
  - job: BuildAndTest
    displayName: Build and Test
    pool:
      name: 'Default'
    
    steps:
    - script: |
        python -m venv venv
        source venv/bin/activate
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      displayName: 'Install dependencies'
    
    - script: |
        source venv/bin/activate
        export PYTHONPATH=$(pwd)/src:$PYTHONPATH
        pytest tests --doctest-modules --junitxml=junit/test-results.xml --cov=src --cov-report=xml --cov-report=html
      displayName: 'Run tests'
    
    - task: PublishTestResults@2
      condition: succeededOrFailed()
      inputs:
        testResultsFiles: '**/test-*.xml'
        testRunTitle: 'Publish test results'
    
    - task: PublishCodeCoverageResults@1
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: '$(System.DefaultWorkingDirectory)/**/coverage.xml'
        reportDirectory: '$(System.DefaultWorkingDirectory)/**/htmlcov'
    
    - task: SonarCloudPrepare@1
      inputs:
        SonarCloud: 'devops-ta-sonarcloud-connection'
        organization: 'dmsstaging01'
        scannerMode: 'CLI'
        configMode: 'manual'
        cliProjectKey: 'dmsstaging01_dmsstaging01'
        cliProjectName: 'dmsstaging01'
        cliSources: '.'
        extraProperties: |
          sonar.python.coverage.reportPaths=coverage.xml
          sonar.python.xunit.reportPath=junit/test-results.xml
    
    - task: SonarCloudAnalyze@1
    
    - task: SonarCloudPublish@1
      inputs:
        pollingTimeoutSec: '300'

    # Build and push usando buildx
    - script: |
        # Configurar buildx
        docker buildx create --name mybuilder --driver docker-container --bootstrap
        docker buildx use mybuilder
        
        # Login to ACR usando las variables de Azure
        echo $(ACR_ADMIN_PASSWORD) | docker login $(ACR_LOGIN_SERVER) -u $(ACR_ADMIN_USERNAME) --password-stdin
        
        # Build y push de la imagen multi-arquitectura
        docker buildx build --platform linux/amd64,linux/arm64 \
          --builder mybuilder \
          -t $(ACR_LOGIN_SERVER)/$(IMAGE_REPOSITORY_NAME):$(Build.BuildId) \
          -t $(ACR_LOGIN_SERVER)/$(IMAGE_REPOSITORY_NAME):latest \
          --push \
          .
        
        # Limpiar
        docker buildx rm mybuilder
        docker logout $(ACR_LOGIN_SERVER)
      displayName: 'Build and push multi-arch Docker image'

- stage: DeployToDev
  displayName: Deploy to Dev
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/dev'))
  jobs:
  - deployment: DeployToAKSDev
    displayName: Deploy to AKS Dev
    environment: development
    pool:
      name: 'Default'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Instalar dependencias necesarias
          - script: |
              sudo apt-get update
              sudo apt-get install -y unzip curl apt-transport-https
            displayName: 'Install Prerequisites'

          - task: HelmInstaller@1
            inputs:
              helmVersionToInstall: 'latest'

          # Instalar NGINX Ingress Controller
          - script: |
              helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
              helm repo update
              helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
                --namespace default \
                --set controller.replicaCount=2 \
                --set controller.nodeSelector."kubernetes\.io/os"=linux \
                --set defaultBackend.nodeSelector."kubernetes\.io/os"=linux
            displayName: 'Install NGINX Ingress Controller'

          # Instalar cert-manager
          - script: |
              helm repo add jetstack https://charts.jetstack.io
              helm repo update
              kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
              helm upgrade --install cert-manager jetstack/cert-manager \
                --namespace cert-manager \
                --version v1.13.0 \
                --set installCRDs=true
              # Esperar a que cert-manager esté listo
              kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=120s
            displayName: 'Install cert-manager'

          # Desplegar Redis y la aplicación principal
          - task: Kubernetes@1
            displayName: Deploy Redis and Main App
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'devops-ta-aks-connection'
              namespace: 'default'
              command: 'apply'
              arguments: '-f $(System.DefaultWorkingDirectory)/manifests/redis-deployment.yml -f $(System.DefaultWorkingDirectory)/manifests/redis-service.yml -f $(System.DefaultWorkingDirectory)/manifests/deployment.yml -f $(System.DefaultWorkingDirectory)/manifests/service.yml'

          # Obtener IP y actualizar ingress
          - script: |
              # Esperar a que el ingress controller tenga IP
              echo "Waiting for ingress controller to get IP..."
              while [ -z "$INGRESS_IP" ]; do
                INGRESS_IP=$(kubectl get service ingress-nginx-controller -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
                if [ -z "$INGRESS_IP" ]; then
                  echo "Waiting for IP..."
                  sleep 10
                fi
              done
              echo "Ingress IP: $INGRESS_IP"

              # Actualizar los archivos de ingress y cert-issuer
              sed -i "s/YOUR_IP/$INGRESS_IP/g" $(System.DefaultWorkingDirectory)/manifests/ingress.yml
              
              # Aplicar cert-issuer y ingress
              kubectl apply -f $(System.DefaultWorkingDirectory)/manifests/cert-issuer.yml
              kubectl apply -f $(System.DefaultWorkingDirectory)/manifests/ingress.yml
            displayName: 'Configure Ingress and TLS'

          - script: |
              echo "Deployment Status:"
              kubectl get pods -n default
              kubectl get services -n default
              kubectl get ingress -n default
              echo "Access your application at: https://devops-app.$INGRESS_IP.nip.io"
            displayName: 'Show Deployment Info'

- stage: DeployToProd
  displayName: Deploy to Prod
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  jobs:
  - deployment: DeployToAKSProd
    displayName: Deploy to AKS Prod
    environment: production
    pool:
      name: 'Default'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Instalar dependencias necesarias
          - script: |
              sudo apt-get update
              sudo apt-get install -y unzip curl apt-transport-https
            displayName: 'Install Prerequisites'

          - task: HelmInstaller@1
            inputs:
              helmVersionToInstall: 'latest'

          # Instalar NGINX Ingress Controller
          - script: |
              helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
              helm repo update
              helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
                --namespace default \
                --set controller.replicaCount=2 \
                --set controller.nodeSelector."kubernetes\.io/os"=linux \
                --set defaultBackend.nodeSelector."kubernetes\.io/os"=linux
            displayName: 'Install NGINX Ingress Controller'

          # Instalar cert-manager
          - script: |
              helm repo add jetstack https://charts.jetstack.io
              helm repo update
              kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
              helm upgrade --install cert-manager jetstack/cert-manager \
                --namespace cert-manager \
                --version v1.13.0 \
                --set installCRDs=true
              # Esperar a que cert-manager esté listo
              kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=cert-manager -n cert-manager --timeout=120s
            displayName: 'Install cert-manager'

          # Desplegar Redis y la aplicación principal
          - task: Kubernetes@1
            displayName: Deploy Redis and Main App
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'devops-ta-aks-connection'
              namespace: 'default'
              command: 'apply'
              arguments: '-f $(System.DefaultWorkingDirectory)/manifests/redis-deployment.yml -f $(System.DefaultWorkingDirectory)/manifests/redis-service.yml -f $(System.DefaultWorkingDirectory)/manifests/deployment.yml -f $(System.DefaultWorkingDirectory)/manifests/service.yml'

          # Obtener IP y actualizar ingress
          - script: |
              # Esperar a que el ingress controller tenga IP
              echo "Waiting for ingress controller to get IP..."
              while [ -z "$INGRESS_IP" ]; do
                INGRESS_IP=$(kubectl get service ingress-nginx-controller -n default -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true)
                if [ -z "$INGRESS_IP" ]; then
                  echo "Waiting for IP..."
                  sleep 10
                fi
              done
              echo "Ingress IP: $INGRESS_IP"

              # Actualizar los archivos de ingress y cert-issuer
              sed -i "s/YOUR_IP/$INGRESS_IP/g" $(System.DefaultWorkingDirectory)/manifests/ingress.yml
              
              # Aplicar cert-issuer y ingress
              kubectl apply -f $(System.DefaultWorkingDirectory)/manifests/cert-issuer.yml
              kubectl apply -f $(System.DefaultWorkingDirectory)/manifests/ingress.yml
            displayName: 'Configure Ingress and TLS'

          - script: |
              echo "Deployment Status:"
              kubectl get pods -n default
              kubectl get services -n default
              kubectl get ingress -n default
              echo "Access your application at: https://devops-app.$INGRESS_IP.nip.io"
            displayName: 'Show Deployment Info'